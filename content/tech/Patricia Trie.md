# Patricia Trie (Merkle Patricia Trie - MPT)

## Definition

The Merkle Patricia Trie (often shortened to Patricia Trie or MPT) is a specialized tree-like data structure used extensively in Ethereum and EVM-compatible blockchains like HashKey Chain. It serves as a cryptographically authenticated key-value store, capable of efficiently storing, retrieving, and updating key-value pairs while producing a single, constant-size root hash that uniquely identifies the entire dataset.

Its "Merkle" property ensures data integrity (tamper-proofing), while the "Patricia Trie" (Practical Algorithm To Retrieve Information Coded In Alphanumeric) structure allows for efficient path compression.

## Purpose in Ethereum/EVM Chains

MPTs are fundamental data structures used to represent critical components of the blockchain's state:

1.  **World State Trie (or Account State Trie):** Maps Ethereum addresses (keys) to their corresponding account states (values). The account state typically includes nonce, balance, storage root (hash of the account's storage trie), and code hash. The root hash of *this* trie is stored in the block header as the `stateRoot`.
2.  **Storage Trie (Per Account):** Each account has its own MPT to store its contract storage. It maps 32-byte storage slot keys to their 32-byte values. The root hash of *this* trie is stored within the account state in the World State Trie.
3.  **Transaction Trie:** Stores the transactions included in a specific block. It maps the transaction index within the block (key, e.g., 0, 1, 2...) to the transaction data (value, RLP-encoded). The root hash is stored in the block header as the `transactionsRoot`.
4.  **Receipts Trie:** Stores the transaction receipts generated by executing the transactions in a block. It maps the transaction index (key) to the corresponding receipt (value, including logs, status, gas used). The root hash is stored in the block header as the `receiptsRoot`.

## Key Features and Structure

*   **Key-Value Store:** Maps arbitrary byte arrays (keys) to arbitrary byte arrays (values).
*   **Deterministic:** The same set of key-value pairs always produces the exact same Trie and root hash.
*   **Cryptographic Root Hash:** A single 32-byte hash represents the entire Trie. Any change anywhere in the Trie results in a different root hash. This is essential for consensus, as nodes only need to agree on the root hash.
*   **Merkle Property:** The root hash acts as a cryptographic commitment. It allows for efficient generation and verification of "Merkle Proofs," enabling light clients to verify the inclusion or exclusion of specific key-value pairs without downloading the entire state.

**Node Types:**
The MPT uses a combination of node types to store data efficiently:

1.  **BLANK:** Represents an empty node or terminator.
2.  **Leaf Node:** Contains the final part (suffix) of a key path and the corresponding value. It indicates the end of a path.
3.  **Extension Node:** Contains a shared partial key path (a prefix shared by multiple keys below it) and a pointer (hash) to the next node. Used for path compression when there's only one branch extending from a point.
4.  **Branch Node:** Represents a point where a key path diverges. It has 17 slots:
    *   Slots 0-15 correspond to the 16 possible hexadecimal characters (0-f) that the next nibble (4 bits) in the key path can take. Each slot contains the hash of the child node following that nibble.
    *   Slot 16 optionally stores a value if a key path terminates *at this branch node*.

**Path Encoding (Hexary Prefix or HP Encoding):**
Keys are processed nibble by nibble (4 bits, representing hex characters 0-f). A special encoding prefix is added to node data to distinguish between Leaf and Extension nodes and handle odd/even path lengths compactly.

**Hashing:**
Each node (Leaf, Extension, Branch) is serialized (typically using Recursive Length Prefix - RLP encoding) and then hashed using Keccak-256. Pointers within nodes store the *hashes* of their child nodes, not direct memory pointers. This creates the cryptographic linkage essential for the Merkle property.

## How MPTs Work (Conceptual)

*   **Insertion/Update:** To insert or update a key-value pair, traverse the Trie nibble by nibble based on the key. If a path doesn't exist, create new nodes (Extension, Branch, Leaf). If it exists, update the relevant node. When nodes change, their hashes change, requiring parent node hashes to be recalculated recursively up to the root.
*   **Retrieval:** Traverse the Trie based on the key's nibbles. Follow pointers (hashes) from Branch and Extension nodes until a Leaf node matching the key suffix is found or a BLANK node indicates the key doesn't exist.
*   **Deletion:** Traverse to the node. Remove the value (e.g., setting Leaf value to null or Branch slot 16 to null). Then, simplify the Trie structure: if a Branch node becomes redundant (only one child left), it might merge with its child via an Extension node, or be removed entirely. Hash updates propagate upwards.

## Merkle Proofs

Because of the hashing structure, you can prove that a specific key-value pair exists (or doesn't exist) in the Trie represented by a known root hash by providing only the relevant nodes along the path from the root to the target key. A verifier (like a light client) can take the provided nodes, recalculate the intermediate hashes, and check if the final calculated root hash matches the known, trusted root hash.
